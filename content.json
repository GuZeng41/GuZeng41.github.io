{"meta":{"title":"Guzeng41的笔记","subtitle":"","description":"一个笔记网站","author":"GuZeng41","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2020-11-09T11:06:46.000Z","updated":"2020-11-09T11:45:51.912Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的说说","date":"2020-11-09T11:06:59.000Z","updated":"2020-11-09T11:46:50.884Z","comments":true,"path":"bb/index.html","permalink":"http://example.com/bb/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-11-09T11:07:10.000Z","updated":"2020-11-09T11:07:45.435Z","comments":true,"path":"guestbook/index.html","permalink":"http://example.com/guestbook/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-09T11:06:53.000Z","updated":"2020-11-09T11:32:16.719Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-09T11:07:03.000Z","updated":"2020-11-09T11:46:07.457Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"题解02","slug":"solve-02","date":"2020-11-09T12:30:29.000Z","updated":"2020-11-09T11:43:39.484Z","comments":true,"path":"posts/25719.html","link":"","permalink":"http://example.com/posts/25719.html","excerpt":"","text":"题解02 日常：输出问题及解决USACO Training 1.1.3 Friday the Thirteenth Description 13号又是星期五是一个不寻常的日子吗?13号在星期五比在其他日少吗?为了回答这个问题,写一个程序来计算在n年里13日落在星期一,星期二……星期日的次数.这个测试从1900年1月1日到1900+n-1年12月31日.n是一个非负数且不大于400. 这里有一些你要知道的: 1900年1月1日是星期一.4,6,11和9月有30天.其他月份除了2月都有31天.闰年2月有29天,平年2月有28天.年份可以被4整除的为闰年(1992=4*498 所以 1992年是闰年,但是1990年不是闰年)以上规则不适合于世纪年.可以被400整除的世纪年为闰年,否则为平年.所以,1700,1800,1900和2100年是平年,而2000年是闰年.请不要预先算好数据! Input 一个整数n. Output 七个在一行且相分开的整数,它们代表13日是星期六,星期日,星期一…星期五的次数. Sample Input 1 120 Sample Output 1 136 33 34 33 35 35 34 Source USACO 这里有个超级神奇的现象，我运行了我的代码之后VSC不能输出结果，但是VS却可以，代码最后也是AC的 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#include &lt;map&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); bool is_rn(int x); int month[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; int n,num=1,day=13,mon=0; map &lt;int,int&gt; week; for(int i=1;i&lt;8;i++)week[i]=0; cin&gt;&gt;n; while(num&lt;=n) &#123; if(is_rn(num+1900-1))month[1]=29; mon=0; while (mon&lt;12) &#123; int yu; yu=(day-1)%7+1; week[yu]++; day+=month[mon]; mon++; &#125; month[1]=28; num++; &#125; cout&lt;&lt;week[6]&lt;&lt;&quot; &quot;&lt;&lt;week[7]&lt;&lt;&quot; &quot;; for(int i=1;i&lt;=5;i++)cout&lt;&lt;week[i]&lt;&lt;&quot; &quot;; return 0;&#125;bool is_rn(int x)&#123; if((x%4==0&amp;&amp;x%100!=0)||x%400==0)return true; else return false;&#125; ![image-20201027180120086](C:\\Users\\Gu Zeng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201027180120086.png) ![image-20201027180310781](C:\\Users\\Gu Zeng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201027180310781.png) 阿哲 这究竟是为何？？？？滑稽 最后咨询了yyds 汤大佬 得出的结论是这样的 ![image-20201027180430547](C:\\Users\\Gu Zeng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201027180430547.png) 这个结论对以后写代码调试真的很有帮助啊！！下次不能再有这种低级错误了TTTT 初解broken nacklace首先贴上题目 USACO Training 1.1.4 Broken NecklaceDescription 你有一条由N个红色的，白色的，或蓝色的珠子组成的项链(3&lt;=N&lt;=350)，珠子是随意安排的。 这里是 n=29 的二个例子: 12345678910111213141516171819 1 2 1 2 r b b r b r r b r b b b r r b r r r w r b r w wb b r rb b b bb b r b r r b r b r r r b r r r r r r b r b r r r w 图片 A 图片 B r 代表 红色的珠子 b 代表 蓝色的珠子 w 代表 白色的珠子 第一和第二个珠子在图片中已经被作记号。 图片 A 中的项链可以用下面的字符串表示： brbrrrbbbrrrrrbrrbbrbbbbrrrrb . 假如你要在某点打破项链,展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事。(颜色可能与在这之前收集的不同) 确定应该在哪里打破项链来收集到最大数目的珠子。 Example 举例来说，在图片 A 中的项链，可以收集到8个珠子,在珠子 9 和珠子 10 或珠子 24 和珠子 25 之间打断项链。 在一些项链中，包括白色的珠子如图片 B 所示。 当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。 表现项链的字符串将会包括三符号 r ， b 和 w 。 写一个程序来确定从一条被供应的项链最大可以被收集珠子数目。 Input 第 1 行: N, 珠子的数目 第 2 行: 一串度为N的字符串, 每个字符是 r ， b 或 w Output 单独的一行包含从被供应的项链可以被收集的珠子数目的最大值 Sample Input 1 1229wwwbbrwrbrbrrbrbrwrwwrbwrwrrb Sample Output 1 111 Hint 考虑两段项链（能组成一圈的）。11个珠子已经标注了。 wwwbbrwrbrbrrbrbrwrwwrbwrwrr bwwwbbrwrbrbrrbrbrwrwwrbwrwrrb 1wrwrr bwwwbb 本人（傻鱼）的思路如下：复杂度O(n^2) 分别对字符串的每一个位置进行左右检索。 但是调试的时候遇到很多问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int maxlen(string s, int x);int main()&#123; int N, maxs = 0; string s; cin &gt;&gt; N &gt;&gt; s; for (int i = 0; i &lt; N; i++) &#123; maxs = max(maxs, maxlen(s, i)); &#125; cout &lt;&lt; maxs; system(&quot;pause&quot;); return 0;&#125;int maxlen(string s, int x)&#123; int pos, ans = 0; string s1 = s + s + s; char tmp; pos = s.length() + x; tmp = s1[pos]; while (1) &#123; if (tmp == &#x27;w&#x27;) &#123; tmp = s1[pos + 1], ans++; &#125; else if (tmp != s1[pos] &amp;&amp; s1[pos] != &#x27;w&#x27;)break; else ans++; pos++; //if (pos &gt; s1.length())break; &#125; pos = s.length() + x；//-1// tmp = s1[pos]; while (1) &#123; if (tmp == &#x27;w&#x27;) &#123; tmp = s1[pos - 1], ans++; &#125; else if (tmp != s1[pos] &amp;&amp; s1[pos] != &#x27;w&#x27;)break; else ans++; //if (pos &lt; 2)break; pos--; &#125; int m = s.length(); ans = min(ans, m); return ans;&#125; 其中注释语句是一开始没有加的其实调试的时候一直没有考虑下表的事情，导致一直报错，此外O（n）的解法暂时还没有做出 首先遇到的问题是字符串下标越界 ![image-20201029185534475](C:\\Users\\Gu Zeng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201029185534475.png) 然后我就考虑到如果一整串字符全都为w的情况，此时按照我的思想是没有办法实现break的。于是需要给pos一个限制！ 于是就有了注释的语句，但还是没有成功运行 最终调试的时候发现向左搜索的时候pos的位置应该要减一啊 ![image-20201029185850903](C:\\Users\\Gu Zeng\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201029185850903.png) 不愧是傻鱼 很好，最终还是完成了这个题目 接下来应该会更新对第一周题目的优化 然后我开始学习set了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162set是STL中一种标准关联容器（vector,list,string,deque都是序列容器，而set，multiset，map，multimap是标准关联容器），它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset#include&lt;set&gt;#include&lt;iterator&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;set&lt;int&gt;eg1;//插入eg1.insert(1);eg1.insert(100);eg1.insert(5);eg1.insert(1);//元素1因为已经存在所以set中不会再次插入1eg1.insert(10);eg1.insert(9);//遍历set，可以发现元素是有序的set&lt;int&gt;::iterator set_iter=eg1.begin();cout&lt;&lt;&quot;Set named eg1:&quot;&lt;&lt;endl;for(;set_iter!=eg1.end();set_iter++) cout&lt;&lt;*set_iter&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;//使用size()函数可以获得当前元素个数cout&lt;&lt;&quot;Now there are &quot;&lt;&lt;eg1.size()&lt;&lt;&quot; elements in the set eg1&quot;&lt;&lt;endl;if(eg1.find(200)==eg1.end())//find()函数可以查找元素是否存在 cout&lt;&lt;&quot;200 isn&#x27;t in the set eg1&quot;&lt;&lt;endl;set&lt;int&gt;eg2;for(int i=6;i&lt;15;i++)eg2.insert(i);cout&lt;&lt;&quot;Set named eg2:&quot;&lt;&lt;endl;for(set_iter=eg2.begin();set_iter!=eg2.end();set_iter++) cout&lt;&lt;*set_iter&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;//获得两个set的并set&lt;int&gt;eg3;cout&lt;&lt;&quot;Union:&quot;;set_union(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator&lt;set&lt;int&gt; &gt;(eg3,eg3.begin()));//注意第五个参数的形式copy(eg3.begin(),eg3.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;));cout&lt;&lt;endl;//获得两个set的交，注意进行集合操作之前接收结果的set要调用clear()函数清空一下eg3.clear();set_intersection(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator&lt;set&lt;int&gt; &gt;(eg3,eg3.begin()));cout&lt;&lt;&quot;Intersection:&quot;;copy(eg3.begin(),eg3.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;));cout&lt;&lt;endl;//获得两个set的差eg3.clear();set_difference(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator&lt;set&lt;int&gt; &gt;(eg3,eg3.begin()));cout&lt;&lt;&quot;Difference:&quot;;copy(eg3.begin(),eg3.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;));cout&lt;&lt;endl;//获得两个set的对称差，也就是假设两个集合分别为A和B那么对称差为AUB-A∩B eg3.clear(); set_symmetric_difference(eg1.begin(),eg1.end(),eg2.begin(),eg2.end(),insert_iterator&lt;set&lt;int&gt; &gt;(eg3,eg3.begin())); copy(eg3.begin(),eg3.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;)); cout&lt;&lt;endl;return 0;&#125;set会对元素进行排序，那么问题也就出现了排序的规则是怎样的呢？上面的示例代码我们发现对int型的元素可以自动判断大小顺序，但是对char*就不会自动用strcmp进行判断了，更别说是用户自定义的类型了，事实上set的标准形式是set&lt;Key, Compare, Alloc&gt;，参数 描述 默认值Key 集合的关键字和值的类型 Compare 关键字比较函数，它的参数类型key参数指定的类型，如果第一个参数小于第二个参数则返回true，否则返回false less&lt;Key&gt;Alloc set的分配器，用于内部内存管理 alloc下面给出一个关键字类型为char*的示例代码#include&lt;iostream&gt;#include&lt;iterator&gt;#include&lt;set&gt;using namespace std;struct ltstr&#123;bool operator() (const char* s1, const char* s2) const&#123; return strcmp(s1, s2) &lt; 0;&#125;&#125;;int main()&#123;const int N = 6;const char* a[N] = &#123;&quot;isomer&quot;, &quot;ephemeral&quot;, &quot;prosaic&quot;, &quot;nugatory&quot;, &quot;artichoke&quot;, &quot;serif&quot;&#125;;const char* b[N] = &#123;&quot;flat&quot;, &quot;this&quot;, &quot;artichoke&quot;, &quot;frigate&quot;, &quot;prosaic&quot;, &quot;isomer&quot;&#125;;set&lt;const char*,ltstr&gt; A(a, a + N);set&lt;const char*,ltstr&gt; B(b, b + N);set&lt;const char*,ltstr&gt; C;cout &lt;&lt; &quot;Set A: &quot;;//copy(A.begin(), A.end(), ostream_iterator&lt;const char*&gt;(cout, &quot; &quot;));set&lt;const char*,ltstr&gt;::iterator itr;for(itr=A.begin();itr!=A.end();itr++) cout&lt;&lt;*itr&lt;&lt;&quot; &quot;;cout &lt;&lt; endl;cout &lt;&lt; &quot;Set B: &quot;;copy(B.begin(), B.end(), ostream_iterator&lt;const char*&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl;cout &lt;&lt; &quot;Union: &quot;;set_union(A.begin(), A.end(), B.begin(), B.end(), ostream_iterator&lt;const char*&gt;(cout, &quot; &quot;), ltstr()); cout &lt;&lt; endl;cout &lt;&lt; &quot;Intersection: &quot;;set_intersection(A.begin(), A.end(), B.begin(),B.end(),ostream_iterator&lt;const char*&gt;(cout,&quot; &quot;),ltstr());cout&lt;&lt;endl;set_difference(A.begin(), A.end(), B.begin(), B.end(),inserter(C, C.begin()),ltstr());cout &lt;&lt; &quot;Set C (difference of A and B): &quot;;copy(C.begin(), C.end(), ostream_iterator&lt;const char*&gt;(cout, &quot; &quot;));cout &lt;&lt;endl;return 0;&#125;其中的ltstr也可以这样定义class ltstr&#123; public: bool operator() (const char* s1,const char*s2)const &#123; return strcmp(s1,s2)&lt;0; &#125;&#125;;更加通用的应用方式那就是数据类型也是由用户自定义的类来替代，比较的函数自定义，甚至可以加上二级比较，比如首先按照总分数排序，对于分数相同的按照id排序，下面是示例代码#include&lt;set&gt;#include&lt;iostream&gt;using namespace std;struct&#123; int id; int score; string name;&#125;;struct compare&#123; bool operator()(const Entity&amp; e1,const Entity&amp; e2)const &#123; if(e1.score&lt;e2.score) return true; else if(e1.score==e2.score) if(e1.id&lt;e2.id) return true; return false; &#125;&#125;;int main()&#123; set&lt;Entity,compare&gt;s_test; Entity a,b,c; a.id=123;a.score=90;a.name=&quot;bill&quot;; b.id=121;b.score=85;b.name=&quot;mary&quot;; c.id=130;c.score=85;c.name=&quot;jerry&quot;; s_test.insert(a);s_test.insert(b);s_test.insert(c); set&lt;Entity,compare&gt;::iterator itr; cout&lt;&lt;&quot;Score List(ordered by score):\\n&quot;; for(itr=s_test.begin();itr!=s_test.end();itr++) cout&lt;&lt;itr-&gt;id&lt;&lt;&quot;---&quot;&lt;&lt;itr-&gt;name&lt;&lt;&quot;---&quot;&lt;&lt;itr-&gt;score&lt;&lt;endl; return 0;&#125; insert count begin end rbegin rend lower_bound upper_bound 就是找到容器中第一个大于等于某个树的元素的位置 另一个是大于 阿哲 USACO Training 1.2.1 Milking CowsDescription 三个农民每天清晨5点起床，然后去牛棚给3头牛挤奶。第一个农民在300时刻(从5点开始计时，秒为单位)给他的牛挤奶，一直到1000时刻。第二个农民在700时刻开始，在 1200时刻结束。第三个农民在1500时刻开始2100时刻结束。期间最长的至少有一个农民在挤奶的连续时间为900秒(从300时刻到1200时刻)，而最长的无人挤奶的连续时间(从挤奶开始一直到挤奶结束)为300时刻(从1200时刻到1500时刻)。 你的任务是编一个程序，读入一个有N个农民(1 &lt;= N &lt;= 5000)挤N头牛的工作时间列表，计算以下两点(均以秒为单位): 最长至少有一人在挤奶的时间段。 最长的无人挤奶的时间段。 Input Line 1: 一个整数N。 Lines 2..N+1: 每行两个小于1000000的非负整数，表示一个农民的开始时刻与结束时刻。 Output 一行，两个整数，即题目所要求的两个答案。 Sample Input 1 12343300 1000700 12001500 2100 Sample Output 1 方法1：我的解法思路为将每一段区间的头尾分别存储，然后以左端点进行排序，然后逐一进行遍历比较，记录max 和min，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;long long n,sum,sum2,ans,ans2,k[5050],s[5050],a[10050];int main()&#123; // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); cin &gt;&gt; n; for (int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; k[i] &gt;&gt; s[i]; a[2*i-1]=k[i]; a[2*i]=s[i]; &#125; sort(a+1,a+2*n+1); for (int i=2;i&lt;=2*n;i++) &#123; int p=0; for (int j=1;j&lt;=n;j++) if (a[i]&gt;k[j]&amp;&amp;a[i]&lt;=s[j]) &#123; sum+=a[i]-a[i-1]; ans=max(ans,sum); sum2=0; p=1; break; &#125; if (p==0) &#123; sum2+=a[i]-a[i-1]; ans2=max(ans2,sum2); sum=0; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&quot; &quot;; cout&lt;&lt;ans2&lt;&lt;endl; return 0;&#125; 方法2：结构体sort上面的方法虽然稳定而简单，但是如果数据狠一些就会超时。所以，我们可以不用暴力的方法，使用减法可以算出挤奶时间和未挤奶时间。所以，代码如下（思路看注释） 12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int my_max(int x, int y)&#123; return x &gt; y ? x : y; //取最大值函数，&lt;algorithm&gt;里面的太慢了&#125;int main()&#123; int o; scanf(&quot;%d&quot;, &amp;o); int maxx = -1, maxy = -1, lasttmp = 0; for(int i = 1; i &lt;= o; i ++)&#123; int tmpx, tmpy; scanf(&quot;%d%d&quot;, &amp;tmpx, &amp;tmpy); //边读边做，不用数组 maxx = my_max(maxx, tmpy - tmpx); //更新最长有人挤奶时间的最大值 maxy = my_max(maxy, tmpx - lasttmp);//更新最长无人挤奶时间的最大值 lasttmp = tmpy; //更新上一次挤奶的结束时间 &#125; printf(&quot;%d %d&quot;, maxx, maxy); //输出 return 0;&#125; 如果像我这样提交的话，结果是这样的： 为什么是错误的呢？我想了半天没想出来，于是使用了测试数据下载。第一个测试点是这样的： 121100 200 这样的话，lasttmp是0，而且输入的数据不一定是顺序的。所以，我们需要对数据排序。如果自己手写排序的话，性能很差。所以，我们使用里面的sort函数对我们的数据进行排序。下面我来介绍以下sort的用法 sort在里面，原型有两个： 1234template &lt;class RandomAccessIterator&gt;void sort(RandomAccessIterator first, RandomAccessIterator last);template &lt;class RandomAccessIterator, class Compare&gt;void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp); 第一种原型是对一个数组进行默认的升序排序，第二种却是对数组进行自定义规则的排序。 comp这个参数是一个函数。它对两个和数组类型相同的数进行自定义的比较，如果返回true则不交换，否则交换。对一个有10个元素的数组进行排序，是这样的： 1sort(a, a + 10, cmp); 但是，这样使用sort只能排序一组数字。所以，我们使用结构体，使用自定义的cmp函数对整个数据进行排序。具体思路如下图： 但是，如何定义结构体呢？定义结构体的关键字是struct，是structure的简写。具体格式如下： 12345struct 结构体名&#123; 成员变量; 成员函数;&#125;;结构体名 变量; 结构体在面向对象编程时很有用。但是，它也是sort的绝佳搭档。因为排序时，我们要对一个对象的每一条信息进行交换，而使用数组并不能实现这个功能，所以，使用结构体可以帮助我们完成很多复杂的排序问题。具体参考： 洛谷试炼场普及练习场排序与排序ex 这道题目，我们一个结构体存储每一条信息的和，进行排序，并按图上的思路输出。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int N; struct node&#123; int begin, end;&#125;m[5005];bool cmp(node a, node b)&#123; return a.begin &lt; b.begin;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;N); for(register int i = 1; i &lt;= N; ++ i) //register可以简单理解为对int i 加速 scanf(&quot;%d%d&quot;, &amp;m[i].begin, &amp;m[i].end); sort(m + 1, m + 1 + N, cmp); int begin = m[1].begin; int end = m[1].end; int ans1 = 0, ans2 = 0; for(register int i = 2; i &lt;= N; ++ i)&#123; if(m[i].begin &lt;= end) end = max(end, m[i].end); else&#123; ans1 = max(ans1, end - begin); ans2 = max(ans2, m[i].begin - end); begin = m[i].begin; end = m[i].end; &#125; &#125; ans1 = max(ans1, end - begin); printf(&quot;%d %d&quot;, ans1, ans2); return 0;&#125; 没错这就是想学STL发现指针不会，想学指针学完发现结构体不会，不愧是我，咸鱼之王！ 很好，sort的内部实现先咕咕咕一下把！ 这周比较混乱，运动会第一天和第二天半天去了医院，，，之后想要去补一些内容，时间利用的不好，只补了如下内容，周日也被小熊教育了，深刻反思，接下来会利用好碎片时间好好刷题，同时我觉得语法和算法对我来说也是很重要的。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ ==该区域的数据在程序结束后由操作系统释放==. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123; //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 打印结果： ![1545017602518](E:/Cpp-0-1-Resource-master/第3阶段-C++核心编程 资料/讲义/assets/1545017602518.png) 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​ 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123; int a = 10; return &amp;a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ​ 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​ C++中利用==new==操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== ​ 语法： new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(&quot;pause&quot;); return 0;&#125; 示例2：开辟数组 12345678910111213141516171819202122//堆区开辟数组int main() &#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0;&#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123; int a = 10; int &amp;b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123; int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//1. 值传递void mySwap01(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123; int temp = *a; *a = *b; *b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;int main() &#123; int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; test02() &#123; static int a = 20; return a;&#125;int main() &#123; //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加==const修饰形参==，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123; //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(&quot;pause&quot;); return 0;&#125; 这周题目做得少，这是我的问题，应该反思，或许做不了很多数量的题目，但也应该要认真对待自己遇到的题目。 对我来说，也要努力补上一些核心编程的内容了。 USACO Training 1.2.2 Transformations下面是题解，按照题目翻译条件走下去就OK了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;char a[11][11],b[11][11],c[11][11]; //分别为初始数组，旋转数组和翻转数组bool xz90(int n,char a1[11][11],char b1[11][11])&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(a1[i][j] != b1[j][n+1-i]) return false; &#125; &#125; return true;&#125;bool xz180(int n, char a1[11][11], char b1[11][11])&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(a1[i][j] != b1[n+1-i][n+1-j]) return false; &#125; &#125; return true;&#125;bool xz270(int n, char a1[11][11], char b1[11][11])&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(a1[i][j] != b1[n+1-j][i]) return false; &#125; &#125; return true;&#125;bool fz4(int n,char a1[11][11], char b1[11][11])//水平翻转&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(a1[i][j] != b1[i][n+1-j]) return false; &#125; &#125; return true;&#125;bool fz6(int n, char a1[11][11], char b1[11][11])//不改变&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(b1[i][j] != a1[i][j]) return false; &#125; &#125; return true;&#125;int main()&#123; // ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) //输入初始方阵，同时进行反转 &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; a[i][j]; c[i][n+1-j] = a[i][j]; &#125; &#125; for(int i = 1; i &lt;= n; i++) //输入最终方阵 &#123; for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; b[i][j]; &#125; &#125; if(xz90(n,a,b)) &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; if(xz180(n,a,b)) &#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; if(xz270(n,a,b)) &#123; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; if(fz4(n,a,b)) &#123; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; if(xz90(n,c,b) || xz180(n,c,b) || xz270(n,c,b)) &#123; cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; if(fz6(n,a,b)) &#123; cout &lt;&lt; &quot;6&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0; &#125; cout &lt;&lt; &quot;7&quot; &lt;&lt; endl; //system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"题解02","slug":"题解02","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A302/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"这个是标题","slug":"test","date":"2020-11-09T11:30:29.000Z","updated":"2020-11-09T11:32:48.169Z","comments":true,"path":"posts/43265.html","link":"","permalink":"http://example.com/posts/43265.html","excerpt":"","text":"这个是正文","categories":[{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE1/"},{"name":"标签2","slug":"标签2","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE2/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-09T10:44:04.466Z","updated":"2020-11-09T11:04:02.371Z","comments":true,"path":"posts/16107.html","link":"","permalink":"http://example.com/posts/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"题解02","slug":"题解02","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A302/"},{"name":"分类","slug":"分类","permalink":"http://example.com/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签2","slug":"标签2","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE2/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"},{"name":"标签1","slug":"标签1","permalink":"http://example.com/tags/%E6%A0%87%E7%AD%BE1/"}]}